"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Router = void 0;

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _objectDestructuringEmpty2 = _interopRequireDefault(require("@babel/runtime/helpers/objectDestructuringEmpty"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _ = require("./");

var _inspector = require("./debug/inspector");

var _errors = require("./errors");

var _utils = require("./utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var Router = /*#__PURE__*/function () {
  /**
   * @param {Route[]} routes
   * @param routeInspector
   */
  function Router(routes) {
    var routeInspector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    (0, _classCallCheck2["default"])(this, Router);
    this.routes = routes;
    this.routeInspector = routeInspector || new _inspector.RouteInspector();
  } // eslint-disable-next-line complexity


  (0, _createClass2["default"])(Router, [{
    key: "processInput",
    value: function processInput(input) {
      var session = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var lastRoutePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var routeParams = {};

      if (input.payload && input.payload.includes('__PATH_PAYLOAD__')) {
        var pathParam = input.payload.split('__PATH_PAYLOAD__');
        routeParams.route = this.getRouteByPath(pathParam[1], this.routes);
      }

      var pathParams = this.getOnFinishParams(input);
      var brokenFlow = false;
      var lastRoute = this.getRouteByPath(lastRoutePath, this.routes);
      if (!lastRoute && input.path) routeParams.route = this.getRouteByPath(input.path, this.routes);
      if (lastRoute && lastRoute.childRoutes && !routeParams.route) //get route depending of current ChildRoute
        routeParams = this.getRoute(input, lastRoute.childRoutes, session, lastRoutePath);

      if (!routeParams || !Object.keys(routeParams).length) {
        /*
            we couldn't find a route in the state of the lastRoute, so let's find in
            the general conf.route
          */
        brokenFlow = Boolean(lastRoutePath);
        routeParams = this.getRoute(input, this.routes, session, lastRoutePath);
      }

      try {
        if (pathParams) {
          var searchParams = new URLSearchParams(pathParams);

          var _iterator = _createForOfIteratorHelper(searchParams),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
                  key = _step$value[0],
                  value = _step$value[1];

              routeParams.params ? routeParams.params[key] = value : routeParams.params = (0, _defineProperty2["default"])({}, key, value);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      } catch (e) {}

      if (routeParams && Object.keys(routeParams).length) {
        //get in childRoute if one has path ''
        var defaultAction;

        if (routeParams.route) {
          if (!routeParams.route.path && routeParams.route.childRoutes && routeParams.route.childRoutes.length) {
            defaultAction = this.getRoute({
              path: ''
            }, routeParams.route.childRoutes, session, lastRoutePath);
          }

          if ('action' in routeParams.route) {
            if (brokenFlow && routeParams.route.ignoreRetry != true && lastRoute && (session.__retries || 0) < (lastRoute.retry || 0) && routeParams.route.path != lastRoute.action) {
              session.__retries = session.__retries ? session.__retries + 1 : 1; // The flow was broken, but we want to recover it

              return {
                action: routeParams.route.action,
                params: routeParams.params,
                retryAction: lastRoute ? lastRoute.action : null,
                defaultAction: defaultAction ? defaultAction.route.action : null,
                lastRoutePath: lastRoutePath
              };
            } else {
              session.__retries = 0;
              if (lastRoutePath && !brokenFlow) lastRoutePath = "".concat(lastRoutePath, "/").concat(routeParams.route.path);else lastRoutePath = routeParams.route.path;
              return {
                action: routeParams.route.action,
                params: routeParams.params,
                retryAction: null,
                defaultAction: defaultAction ? defaultAction.route.action : null,
                lastRoutePath: lastRoutePath
              };
            }
          } else if (defaultAction) {
            return {
              action: defaultAction.route.action,
              params: defaultAction.params,
              lastRoutePath: lastRoutePath
            };
          } else if ('redirect' in routeParams.route) {
            lastRoutePath = routeParams.route.redirect;
            var redirectRoute = this.getRouteByPath(lastRoutePath, this.routes);

            if (redirectRoute) {
              return {
                action: redirectRoute.action,
                params: redirectRoute.params,
                lastRoutePath: lastRoutePath
              };
            }
          }
        }
      }

      var notFound = this.getRouteByPath('404', this.routes);
      if (!notFound) throw new _errors.NoMatchingRouteError(input);

      if (lastRoute && (session.__retries || 0) < (lastRoute.retry || 0)) {
        session.__retries = session.__retries ? session.__retries + 1 : 1;
        return {
          action: notFound.action,
          params: {},
          retryAction: lastRoute.action,
          lastRoutePath: lastRoutePath
        };
      } else {
        this.lastRoutePath = null;
        session.__retries = 0;
        return {
          action: notFound.action,
          params: {},
          retryAction: null,
          lastRoutePath: lastRoutePath
        };
      }
    }
    /**
     * @param {Input} input
     * @return {string|undefined}
     */

  }, {
    key: "getOnFinishParams",
    value: function getOnFinishParams(input) {
      try {
        if (!input.payload) {
          return undefined;
        }

        var params = input.payload.split('__PATH_PAYLOAD__');

        if (params.length < 2) {
          return undefined;
        }

        var pathParams = params[1].split('?');

        if (pathParams.length > 0) {
          input.path = pathParams[0];
          delete input.payload;
        }

        if (pathParams.length > 1) {
          return pathParams[1];
        }
      } catch (e) {
        console.error('ERROR getOnFinishParams', e);
      }

      return undefined;
    }
    /**
     * @return {null|RouteParams}
     */

  }, {
    key: "getRoute",
    value: function getRoute(input, routes, session, lastRoutePath) {
      var _this = this;

      var computedRoutes = (0, _utils.isFunction)(routes) ? routes({
        input: input,
        session: session,
        lastRoutePath: lastRoutePath
      }) : routes;
      /* Find the route that matches the given input, if it match with some of the entries,
        return the whole Route of the entry with optional params captured if matcher was a regex */

      /** @type {{ [key: string]: string }}*/

      var params = {};
      var route = computedRoutes.find(function (r) {
        return Object.entries(r).filter(function (_ref) {
          var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
              key = _ref2[0];

          (0, _objectDestructuringEmpty2["default"])(_ref2[1]);
          return key != 'action' && key != 'childRoutes';
        }).some(function (_ref3) {
          var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2),
              key = _ref4[0],
              value = _ref4[1];

          var match = _this.matchRoute(r, key, value, input, session, lastRoutePath);

          try {
            params = match.groups;
          } catch (e) {}

          return Boolean(match);
        });
      });

      if (route) {
        return {
          route: route,
          params: params
        };
      }

      return null;
    }
    /**
     * @param {string|null} path
     * @param {Route[]?} routeList
     * @return {null|Route}
     */

  }, {
    key: "getRouteByPath",
    value: function getRouteByPath(path) {
      var routeList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (!path) return null;
      var route = null;
      routeList = routeList || this.routes;

      var _path$split = path.split('/'),
          _path$split2 = (0, _toArray2["default"])(_path$split),
          currentPath = _path$split2[0],
          childPath = _path$split2.slice(1);

      var _iterator2 = _createForOfIteratorHelper(routeList),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var r = _step2.value;

          //iterate over all routeList
          if (r.path == currentPath) {
            route = r;

            if (r.childRoutes && r.childRoutes.length && childPath.length > 0) {
              //evaluate childroute over next actions
              route = this.getRouteByPath(childPath.join('/'), r.childRoutes);
              if (route) return route;
            } else if (childPath.length === 0) return route; //last action and found route

          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return null;
    }
    /**
     * @return {Params|boolean}
     */

  }, {
    key: "matchRoute",
    value: function matchRoute(route, prop, matcher, input, session, lastRoutePath) {
      /*
          prop: ('text' | 'payload' | 'intent' | 'type' | 'input' | 'session' | 'request' ...)
          matcher: (string: exact match | regex: regular expression match | function: return true)
          input: user input object, ex: {type: 'text', data: 'Hi'}
        */

      /** @type {any} */
      var value = '';
      if (Object.keys(input).indexOf(prop) > -1) value = input[prop];

      if (prop === 'text') {
        if (input.type === 'text') value = input.data;
      } else if (prop === 'input') value = input;else if (prop === 'session') value = session;else if (prop === 'request') value = {
        input: input,
        session: session,
        lastRoutePath: lastRoutePath
      };

      var matched = this.matchValue(matcher, value);

      if (matched) {
        this.routeInspector.routeMatched(route, prop, matcher, value);
      } else {
        this.routeInspector.routeNotMatched(route, prop, matcher, value);
      }

      return matched;
    }
    /**
     *
     * @return {*|boolean|Params}
     */

  }, {
    key: "matchValue",
    value: function matchValue(matcher, value) {
      if (typeof matcher === 'string') {
        // TODO should this be === to avoid matching '' with undefined?
        return value == matcher;
      }

      if (matcher instanceof RegExp) {
        // check if undefined to avoid conversion to 'undefined'
        if (value === undefined) {
          return false;
        }

        return matcher.exec(value);
      }

      if (typeof matcher === 'function') {
        return matcher(value);
      }

      return false;
    }
  }]);
  return Router;
}();

exports.Router = Router;
//# sourceMappingURL=router.js.map